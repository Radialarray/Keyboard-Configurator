//! Firmware generation for QMK keymap.c and vial.json.
//!
//! This module generates QMK C code and Vial JSON configuration
//! from keyboard layouts using the LED index order.

use crate::config::{Config, LightingMode};
use crate::models::keyboard_geometry::KeyboardGeometry;
use crate::models::layout::Layout;
use crate::models::visual_layout_mapping::VisualLayoutMapping;
use anyhow::{Context, Result};
use serde_json::json;
use std::fs;

/// Firmware generator for keymap.c and vial.json.
pub struct FirmwareGenerator<'a> {
    layout: &'a Layout,
    geometry: &'a KeyboardGeometry,
    mapping: &'a VisualLayoutMapping,
    config: &'a Config,
}

impl<'a> FirmwareGenerator<'a> {
    /// Creates a new firmware generator.
    #[must_use]
    pub const fn new(
        layout: &'a Layout,
        geometry: &'a KeyboardGeometry,
        mapping: &'a VisualLayoutMapping,
        config: &'a Config,
    ) -> Self {
        Self {
            layout,
            geometry,
            mapping,
            config,
        }
    }

    /// Generates keymap.c, vial.json, and config.h files.
    ///
    /// Files are written to both:
    /// 1. Timestamped output directory (for archival)
    /// 2. QMK keymap directory (for building)
    ///
    /// Returns paths to the generated files in the timestamped directory.
    pub fn generate(&self) -> Result<(String, String, String)> {
        // Create timestamped output directory
        let timestamp_dir = self.create_timestamped_output_dir()?;

        // Generate config.h (merge with keyboard config if exists)
        let config_h = self.generate_merged_config_h()?;
        let config_h_path = self.write_file_to_both(&timestamp_dir, "config.h", &config_h)?;

        // Generate keymap.c
        let keymap_c = self.generate_keymap_c()?;
        let keymap_path = self.write_file_to_both(&timestamp_dir, "keymap.c", &keymap_c)?;

        // Generate vial.json
        let vial_json = self.generate_vial_json()?;
        let vial_path = self.write_file_to_both(&timestamp_dir, "vial.json", &vial_json)?;

        Ok((keymap_path, vial_path, config_h_path))
    }

    /// Generates keymap.c C code.
    ///
    /// Creates a QMK keymap file with PROGMEM arrays for each layer.
    /// Keys are ordered by LED index as required by QMK.
    fn generate_keymap_c(&self) -> Result<String> {
        let mut code = String::new();

        // File header
        code.push_str("// Generated by keyboard_tui\n");
        code.push_str(&format!("// Layout: {}\n", self.layout.metadata.name));
        code.push_str(&format!("// Keyboard: {}\n", self.config.build.keyboard));
        code.push_str(&format!(
            "// Layout Variant: {}\n",
            self.config.build.layout
        ));
        code.push('\n');

        // Includes
        code.push_str("#include QMK_KEYBOARD_H\n\n");

        // Keymap definition
        code.push_str("const uint16_t PROGMEM keymaps[][MATRIX_ROWS][MATRIX_COLS] = {\n");

        // Generate each layer
        for (layer_idx, layer) in self.layout.layers.iter().enumerate() {
            code.push_str(&format!("    // Layer {}: {}\n", layer_idx, layer.name));
            code.push_str(&format!(
                "    [{}] = {}(",
                layer_idx, self.config.build.layout
            ));

            // Generate keys in LED order
            let keys_by_led = self.generate_layer_keys_by_led(layer)?;

            // Format keys (wrap at reasonable line length)
            let keys_str = keys_by_led.join(", ");
            if keys_str.len() > 80 {
                // Multi-line formatting
                code.push_str("\n        ");
                for (idx, keycode) in keys_by_led.iter().enumerate() {
                    code.push_str(keycode);
                    if idx < keys_by_led.len() - 1 {
                        code.push_str(", ");
                    }
                    // Line wrap every 6 keys
                    if (idx + 1) % 6 == 0 && idx < keys_by_led.len() - 1 {
                        code.push_str("\n        ");
                    }
                }
                code.push_str("\n    ");
            } else {
                // Single line formatting
                code.push_str(&keys_str);
            }

            code.push(')');
            if layer_idx < self.layout.layers.len() - 1 {
                code.push_str(",\n");
            } else {
                code.push('\n');
            }
        }

        code.push_str("};\n");

        // Add conditional encoder_map (only when ENCODER_MAP_ENABLE is defined)
        code.push('\n');
        code.push_str(&self.generate_conditional_encoder_map()?);

        // Add optional RGB matrix base color table when RGB is present.
        code.push('\n');
        code.push_str(&self.generate_rgb_matrix_color_table()?);

        // Add optional static RGB matrix section when lighting_mode is enabled
        if matches!(self.config.build.lighting_mode, LightingMode::LayoutStatic) {
            code.push('\n');
            code.push_str(&self.generate_static_rgb_matrix_section()?);
        }

        Ok(code)
    }

    /// Generates a static RGB matrix section using layout colors when enabled.
    fn generate_static_rgb_matrix_section(&self) -> Result<String> {
        let mut code = String::new();

        code.push_str("#ifdef RGB_MATRIX_ENABLE\n");
        code.push_str("// Static per-key RGB colors generated from layout colors (layer 0).\n");

        let colors = self.generate_layer_colors_by_led(0)?;
        code.push_str(&format!(
            "static const uint8_t PROGMEM layout_colors[RGB_MATRIX_LED_COUNT][3] = {{\n"
        ));

        for (idx, color) in colors.iter().enumerate() {
            code.push_str(&format!(
                "    /* LED {:3} */ {{{:3}, {:3}, {:3}}},\n",
                idx, color.r, color.g, color.b
            ));
        }

        code.push_str("};\n\n");

        code.push_str("bool rgb_matrix_indicators_user(void) {\n");
        code.push_str("    for (uint8_t i = 0; i < RGB_MATRIX_LED_COUNT; i++) {\n");
        code.push_str("        uint8_t r = layout_colors[i][0];\n");
        code.push_str("        uint8_t g = layout_colors[i][1];\n");
        code.push_str("        uint8_t b = layout_colors[i][2];\n");
        code.push_str("        rgb_matrix_set_color(i, r, g, b);\n");
        code.push_str("    }\n");
        code.push_str("    return true;\n");
        code.push_str("}\n");
        code.push_str("#endif // RGB_MATRIX_ENABLE\n");

        Ok(code)
    }

    /// Generates a conditional encoder_map wrapped in #ifdef ENCODER_MAP_ENABLE.
    ///
    /// This allows the keymap to work both with and without encoders enabled.
    /// When ENCODER_MAP_ENABLE is defined in rules.mk, this encoder_map will be included.
    fn generate_conditional_encoder_map(&self) -> Result<String> {
        let mut code = String::new();

        code.push_str("#ifdef ENCODER_MAP_ENABLE\n");
        code.push_str("const uint16_t PROGMEM encoder_map[][NUM_ENCODERS][NUM_DIRECTIONS] = {\n");

        // Generate encoder bindings for each layer
        // We use RGB controls as sensible defaults that work on most keyboards
        for (layer_idx, _layer) in self.layout.layers.iter().enumerate() {
            code.push_str(&format!("    [{}] = {{\n", layer_idx));
            code.push_str("        ENCODER_CCW_CW(RGB_MOD, RGB_RMOD),\n");
            code.push_str("        ENCODER_CCW_CW(RGB_HUI, RGB_HUD),\n");
            code.push_str("        ENCODER_CCW_CW(RGB_VAI, RGB_VAD),\n");
            code.push_str("        ENCODER_CCW_CW(RGB_SAI, RGB_SAD),\n");
            code.push_str("    }");

            if layer_idx < self.layout.layers.len() - 1 {
                code.push_str(",\n");
            } else {
                code.push_str(",\n");
            }
        }

        code.push_str("};\n");
        code.push_str("#endif\n");

        Ok(code)
    }

    /// Generates key assignments for a layer ordered by LED index.
    ///
    /// This is the critical transformation: visual position -> matrix -> LED order.
    fn generate_layer_keys_by_led(
        &self,
        layer: &crate::models::layer::Layer,
    ) -> Result<Vec<String>> {
        let led_count = self.mapping.key_count();
        let mut keys_by_led = vec![String::from("KC_NO"); led_count];

        // Map each key to its LED position
        for key in &layer.keys {
            let visual_pos = key.position;

            // Visual -> Matrix
            let matrix_pos = self
                .mapping
                .visual_to_matrix_pos(visual_pos.row, visual_pos.col)
                .with_context(|| {
                    format!(
                        "Failed to map visual position ({}, {}) to matrix",
                        visual_pos.row, visual_pos.col
                    )
                })?;

            // Matrix -> LED
            let led_idx = self
                .mapping
                .visual_to_led_index(visual_pos.row, visual_pos.col)
                .with_context(|| {
                    format!(
                        "Failed to map matrix position ({}, {}) to LED index",
                        matrix_pos.0, matrix_pos.1
                    )
                })?;

            // Store keycode at LED position
            keys_by_led[led_idx as usize] = key.keycode.clone();
        }

        Ok(keys_by_led)
    }

    /// Generates resolved colors for a layer ordered by LED index.
    ///
    /// Colors use the same visual -> LED mapping as `generate_layer_keys_by_led`
    /// and honor the layout's four-level color priority system.
    fn generate_layer_colors_by_led(&self, layer_idx: usize) -> Result<Vec<crate::models::RgbColor>> {
        let led_count = self.mapping.key_count();
        let mut colors_by_led = vec![crate::models::RgbColor::default(); led_count];

        let layer = self
            .layout
            .get_layer(layer_idx)
            .with_context(|| format!("Invalid layer index {}", layer_idx))?;

        // Map each key's resolved color to its LED position
        for key in &layer.keys {
            let visual_pos = key.position;

            let led_idx = self
                .mapping
                .visual_to_led_index(visual_pos.row, visual_pos.col)
                .with_context(|| {
                    format!(
                        "Failed to map visual position ({}, {}) to LED index",
                        visual_pos.row, visual_pos.col
                    )
                })?;

            let color = self.layout.resolve_key_color(layer_idx, key);
            colors_by_led[led_idx as usize] = color;
        }

        Ok(colors_by_led)
    }

    /// Returns true if the layout uses any custom color semantics.
    ///
    /// This treats the layout as "colored" if:
    /// - Any layer default color differs from the global default (white), or
    /// - Any layer has a category, or
    /// - Any key has a color override or category, or
    /// - The layout defines any categories at all.
    fn layout_has_custom_colors(&self) -> bool {
        if !self.layout.categories.is_empty() {
            return true;
        }

        let default_color = crate::models::RgbColor::default();

        for layer in &self.layout.layers {
            if layer.default_color != default_color {
                return true;
            }

            if layer.category_id.is_some() {
                return true;
            }

            for key in &layer.keys {
                if key.color_override.is_some() || key.category_id.is_some() {
                    return true;
                }
            }
        }

        false
    }

    /// Generates an RGB matrix base color table in C when RGB is present.
    ///
    /// The table layout is:
    /// `const uint8_t PROGMEM layer_base_colors[NUM_LAYERS][RGB_MATRIX_LED_COUNT][3]`.
    fn generate_rgb_matrix_color_table(&self) -> Result<String> {
        // If the keyboard has no RGB matrix (no keys), emit an empty string
        // to avoid unused data in non-RGB builds.
        if !self.geometry.has_rgb_matrix() {
            return Ok(String::new());
        }

        let mut code = String::new();
        let layer_count = self.layout.layers.len();
        let led_count = self.mapping.key_count();

        code.push_str("#ifdef RGB_MATRIX_ENABLE\n");
        code.push_str(&format!(
            "const uint8_t PROGMEM layer_base_colors[{}][{}][3] = {{\n",
            layer_count, led_count
        ));

        for layer_idx in 0..layer_count {
            let colors = self.generate_layer_colors_by_led(layer_idx)?;
            code.push_str("    {\n");

            for (led_idx, color) in colors.iter().enumerate() {
                code.push_str(&format!(
                    "        {{{:3}, {:3}, {:3}}}",
                    color.r, color.g, color.b
                ));

                if led_idx < colors.len() - 1 {
                    code.push_str(",");
                }

                code.push_str("\n");
            }

            code.push_str("    }");
            if layer_idx < layer_count - 1 {
                code.push_str(",\n");
            } else {
                code.push_str("\n");
            }
        }

        code.push_str("};\n");
        code.push_str(&format!(
            "const uint8_t PROGMEM layer_base_colors_layer_count = {};;\n",
            layer_count
        ));
        code.push_str("#endif\n");

        Ok(code)
    }

    /// Generates vial.json configuration.
    ///
    /// Creates a Vial JSON file with layout definition and metadata.
    fn generate_vial_json(&self) -> Result<String> {
        let lighting_value = match self.config.build.lighting_mode {
            LightingMode::QmkDefault => "none",
            // For now, advertise standard QMK RGB matrix lighting when using layout_static.
            LightingMode::LayoutStatic => "qmk_rgblight",
        };

        let vial_config = json!({
            "name": self.layout.metadata.name,
            "vendor_product_id": "0xFEED:0x0000", // Default, should be overridden
            "lighting": lighting_value,
            "matrix": {
                "rows": self.geometry.matrix_rows,
                "cols": self.geometry.matrix_cols
            },
            "layouts": {
                "keymap": self.generate_vial_layout_array()?
            },
            "layers": self.layout.layers.len(),
            "author": self.layout.metadata.author,
            "description": self.layout.metadata.description,
            "tags": self.layout.metadata.tags
        });

        let json_str =
            serde_json::to_string_pretty(&vial_config).context("Failed to serialize vial.json")?;

        Ok(json_str)
    }

    /// Generates the Vial layout array.
    ///
    /// Creates the visual key layout for the Vial UI.
    fn generate_vial_layout_array(&self) -> Result<serde_json::Value> {
        let mut layout_keys = Vec::new();

        // Get all keys from first layer (geometry is same for all layers)
        let first_layer = self
            .layout
            .layers
            .first()
            .context("Layout must have at least one layer")?;

        for key in &first_layer.keys {
            // Get key geometry via LED mapping
            let led_idx = self
                .mapping
                .visual_to_led_index(key.position.row, key.position.col)
                .context("Failed to map key to LED index")?;

            let key_geom = self
                .geometry
                .get_key_by_led(led_idx)
                .context("Failed to get key geometry")?;

            // Create Vial key definition
            // Format: [x, y, width, height, matrix_row, matrix_col]
            layout_keys.push(json!([
                key_geom.visual_x,
                key_geom.visual_y,
                key_geom.width,
                key_geom.height,
                key_geom.matrix_position.0,
                key_geom.matrix_position.1
            ]));
        }

        Ok(json!(layout_keys))
    }

    /// Gets the keymap output directory.
    ///
    /// Creates directory structure if it doesn't exist:
    /// {`qmk_firmware}/keyboards/{keyboard}/keymaps/{keymap`}/
    ///
    /// The keyboard path may include variant subdirectories (e.g., "keebart/corne_choc_pro/standard").
    /// The keymap directory is created under the exact keyboard path used for building.
    fn get_keymap_directory(&self) -> Result<std::path::PathBuf> {
        let qmk_path = self
            .config
            .paths
            .qmk_firmware
            .as_ref()
            .context("QMK firmware path not configured")?;

        // Use the full keyboard path from config (which may include a variant)
        // E.g., "keebart/corne_choc_pro/standard" -> keyboards/keebart/corne_choc_pro/standard/keymaps/{keymap}
        let keymap_dir = qmk_path
            .join("keyboards")
            .join(&self.config.build.keyboard)
            .join("keymaps")
            .join(&self.config.build.keymap);

        // Create directory if it doesn't exist
        fs::create_dir_all(&keymap_dir)
            .with_context(|| format!("Failed to create directory {}", keymap_dir.display()))?;

        Ok(keymap_dir)
    }

    /// Creates a timestamped output directory for this build.
    ///
    /// Format: {output_dir}/{keyboard}_{keymap}_{YYYYMMDD_%H%M%S}/
    fn create_timestamped_output_dir(&self) -> Result<std::path::PathBuf> {
        let timestamp = chrono::Local::now().format("%Y%m%d_%H%M%S");
        let dir_name = format!("{}_{}_{}",
            self.config.build.keyboard.replace('/', "_"),
            self.config.build.keymap,
            timestamp
        );

        let output_dir = self.config.build.output_dir.join(dir_name);

        fs::create_dir_all(&output_dir)
            .with_context(|| format!("Failed to create output directory {}", output_dir.display()))?;

        Ok(output_dir)
    }

    /// Writes a file to both the timestamped archive and the QMK keymap directory.
    ///
    /// Returns the path in the timestamped directory.
    fn write_file_to_both(
        &self,
        timestamp_dir: &std::path::Path,
        filename: &str,
        content: &str,
    ) -> Result<String> {
        // Write to timestamped archive directory
        let archive_path = timestamp_dir.join(filename);
        fs::write(&archive_path, content)
            .with_context(|| format!("Failed to write {}", archive_path.display()))?;

        // Write to QMK keymap directory
        let keymap_dir = self.get_keymap_directory()?;
        let qmk_path = keymap_dir.join(filename);
        fs::write(&qmk_path, content)
            .with_context(|| format!("Failed to write {}", qmk_path.display()))?;

        Ok(archive_path.display().to_string())
    }

    /// Generates config.h for the keymap.
    ///
    /// This generates a minimal keymap-specific config.h.
    /// Note: RGB_MATRIX_LED_COUNT should be defined in the keyboard's variant-specific
    /// keyboard.json file, not in the keymap config.h.
    fn generate_merged_config_h(&self) -> Result<String> {
        let mut content = String::new();

        // Add our generated configuration
        content.push_str("// Generated by KeyboardConfigurator\n");
        content.push_str(&format!("// Layout: {}\n", self.layout.metadata.name));
        content.push_str(&format!("// Generated: {}\n", chrono::Local::now().format("%Y-%m-%d %H:%M:%S")));
        content.push_str("\n");
        content.push_str("#pragma once\n");
        content.push_str("\n");
        content.push_str("// Add keymap-specific configuration here\n");

        // If the keyboard has RGB matrix and the layout defines
        // any custom colors, default to the TUI-driven lighting
        // mode so firmware reflects the editor by default.
        if self.geometry.has_rgb_matrix() && self.layout_has_custom_colors() {
            content.push_str("\n// Default to TUI layer-aware RGB colors when available\n");
            content.push_str("#ifdef RGB_MATRIX_ENABLE\n");
            content.push_str("#    undef RGB_MATRIX_DEFAULT_MODE\n");
            content.push_str("#    define RGB_MATRIX_DEFAULT_MODE RGB_MATRIX_TUI_LAYER_COLORS\n");
            content.push_str("#    define LAYER_BASE_COLORS_LAYER_COUNT ");
            content.push_str(&format!("{}\n", self.layout.layers.len()));
            content.push_str("#endif\n");
        }

        // If this keyboard already has a Vial keymap, copy its unlock combo macros
        // so that quantum/vial.c can compile for the generated keymap as well.
        if let Some(qmk_path) = &self.config.paths.qmk_firmware {
            // Vial unlock combo is defined at the base keyboard level (without variant).
            // E.g., keebart/corne_choc_pro/keymaps/vial/config.h
            let keyboard_parts: Vec<&str> = self.config.build.keyboard.split('/').collect();
            let base_keyboard = if keyboard_parts.len() > 2 {
                keyboard_parts[..keyboard_parts.len() - 1].join("/")
            } else {
                self.config.build.keyboard.clone()
            };

            let vial_config_path = qmk_path
                .join("keyboards")
                .join(&base_keyboard)
                .join("keymaps")
                .join("vial")
                .join("config.h");

            if let Ok(vial_config) = fs::read_to_string(&vial_config_path) {
                let mut rows_define: Option<String> = None;
                let mut cols_define: Option<String> = None;

                for line in vial_config.lines() {
                    let trimmed = line.trim();
                    if trimmed.starts_with("#define VIAL_UNLOCK_COMBO_ROWS") {
                        rows_define = Some(trimmed.to_string());
                    } else if trimmed.starts_with("#define VIAL_UNLOCK_COMBO_COLS") {
                        cols_define = Some(trimmed.to_string());
                    }
                }

                if rows_define.is_some() || cols_define.is_some() {
                    content.push_str("\n// Vial unlock combo copied from keymaps/vial/config.h\n");
                    if let Some(rows) = rows_define {
                        content.push_str(&rows);
                        content.push('\n');
                    }
                    if let Some(cols) = cols_define {
                        content.push_str(&cols);
                        content.push('\n');
                    }
                }
            }
        }

        Ok(content)
    }
}
